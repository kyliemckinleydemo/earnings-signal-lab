<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Earnings Signal Lab</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Instrument+Serif&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #06060f; --bg2: #0c0c1a; --bg3: #12122a;
    --border: #1a1a35; --text: #d4d4e8; --dim: #6b7094;
    --green: #3de8a0; --red: #f06878; --amber: #f0c848;
    --blue: #5898f0; --purple: #a878f0;
    --mono: 'IBM Plex Mono', monospace;
    --serif: 'Instrument Serif', serif;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:var(--bg); color:var(--text); font-family:var(--mono); font-size:13px; line-height:1.5; min-height:100vh; }
  a { color:var(--blue); text-decoration:none; }

  .header { background:linear-gradient(180deg, var(--bg2), var(--bg)); border-bottom:1px solid var(--border); padding:28px 32px 20px; }
  .header h1 { font-family:var(--serif); font-size:32px; font-weight:400; letter-spacing:-0.5px; margin-bottom:4px; }
  .header h1 span.g { color:var(--green); }
  .header h1 span.b { color:var(--blue); }
  .header .meta { font-size:11px; color:var(--dim); }
  .header .meta strong { color:var(--text); font-weight:500; }

  /* Source selector */
  .source-bar { display:flex; gap:6px; margin-top:12px; }
  .source-btn { background:transparent; border:1px solid var(--border); color:var(--dim); border-radius:6px; padding:5px 14px; font:500 11px var(--mono); cursor:pointer; transition:all 0.15s; text-transform:uppercase; letter-spacing:0.5px; }
  .source-btn:hover { border-color:var(--dim); color:var(--text); }
  .source-btn.active { background:rgba(61,232,160,0.08); border-color:var(--green); color:var(--green); }
  .source-btn.unavailable { opacity:0.35; cursor:not-allowed; }

  .tabs { display:flex; gap:0; border-bottom:1px solid var(--border); padding:0 32px; background:var(--bg); position:sticky; top:0; z-index:10; }
  .tab { background:none; border:none; border-bottom:2px solid transparent; color:var(--dim); padding:11px 18px; font:600 11px/1 var(--mono); cursor:pointer; text-transform:uppercase; letter-spacing:1px; transition:all 0.15s; }
  .tab:hover { color:var(--text); }
  .tab.active { color:var(--green); border-bottom-color:var(--green); }

  .content { padding:24px 32px; max-width:1400px; }

  /* Cards */
  .card { background:var(--bg2); border:1px solid var(--border); border-radius:8px; padding:16px; margin-bottom:12px; transition:border-color 0.15s; }
  .card:hover { border-color:var(--dim); }
  .card.selected { border-color:var(--green); }

  /* Feature list */
  .features-grid { display:grid; grid-template-columns:1fr 1.6fr; gap:16px; }
  .feat-list { display:flex; flex-direction:column; gap:8px; max-height:82vh; overflow-y:auto; padding-right:8px; }
  .feat-list::-webkit-scrollbar { width:4px; }
  .feat-list::-webkit-scrollbar-thumb { background:var(--border); border-radius:2px; }

  .feat-card { cursor:pointer; }
  .feat-name { font-size:12px; font-weight:600; margin-bottom:2px; }
  .feat-desc { font-size:10px; color:var(--dim); }
  .feat-tag { font-size:9px; padding:1px 6px; border-radius:3px; display:inline-block; margin-top:3px; }
  .feat-stats { display:flex; gap:10px; margin-top:6px; font-size:10px; color:var(--dim); }
  .feat-ic { font-size:17px; font-weight:700; text-align:right; }

  /* Period grid */
  .period-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:8px; margin-bottom:20px; }
  .period-box { background:var(--bg3); border-radius:6px; padding:10px; text-align:center; }
  .period-label { font-size:10px; color:var(--dim); margin-bottom:4px; }
  .period-ic { font-size:20px; font-weight:700; }
  .period-stats { font-size:10px; color:var(--dim); margin-top:6px; line-height:1.6; }

  /* Samples */
  .sample { background:var(--bg3); border-radius:6px; padding:10px; margin-bottom:6px; border-left:3px solid var(--dim); }

  /* Combos */
  .combo { border-left:3px solid var(--amber); }

  /* Model comparison */
  .model-row { display:flex; justify-content:space-between; align-items:center; padding:8px 12px; border-radius:4px; margin-bottom:4px; }
  .model-row:nth-child(1) { background:rgba(61,232,160,0.08); }
  .model-bar { height:6px; border-radius:3px; background:var(--green); transition:width 0.3s; }

  /* Summary */
  .summary-content { font-size:13px; line-height:1.8; max-width:800px; }
  .summary-content h2 { font-family:var(--serif); font-size:22px; font-weight:400; color:var(--green); margin:28px 0 12px; }
  .summary-content h2:first-child { margin-top:0; }
  .summary-content strong { color:var(--text); font-weight:600; }
  .summary-content ul { margin:8px 0 8px 20px; }
  .summary-content li { margin-bottom:4px; }
  .summary-content code { background:var(--bg3); padding:1px 5px; border-radius:3px; font-size:12px; }

  /* Filters */
  .filters { display:flex; gap:5px; margin-bottom:14px; flex-wrap:wrap; }
  .filter-btn { background:transparent; border:1px solid var(--border); color:var(--dim); border-radius:5px; padding:4px 11px; font:500 10px var(--mono); cursor:pointer; transition:all 0.15s; }
  .filter-btn:hover { border-color:var(--dim); }
  .filter-btn.active { background:var(--bg3); border-color:var(--green); color:var(--green); }

  /* Correlation table */
  .corr-table { border-collapse:collapse; }
  .corr-table th { font-size:8px; font-weight:500; padding:3px; writing-mode:vertical-lr; transform:rotate(180deg); height:70px; text-align:left; }
  .corr-table td.label { font-size:9px; font-weight:500; white-space:nowrap; padding:3px 6px 3px 0; }
  .corr-cell { border-radius:2px; padding:4px 2px; font-size:9px; text-align:center; min-width:32px; }

  /* Scores tab */
  .signal-bar { display:flex; border-radius:6px; overflow:hidden; height:28px; margin-bottom:16px; font-size:11px; font-weight:600; }
  .signal-bar div { display:flex; align-items:center; justify-content:center; gap:4px; }
  .signal-long { background:rgba(61,232,160,0.15); color:var(--green); }
  .signal-neutral { background:rgba(107,112,148,0.15); color:var(--dim); }
  .signal-short { background:rgba(240,104,120,0.15); color:var(--red); }

  .scores-layout { display:grid; grid-template-columns:1fr 320px; gap:16px; }
  @media (max-width:1100px) { .scores-layout { grid-template-columns:1fr; } }

  .scores-table { width:100%; border-collapse:collapse; font-size:11px; }
  .scores-table th { text-align:left; font-size:10px; font-weight:600; color:var(--dim); padding:6px 8px; border-bottom:1px solid var(--border); text-transform:uppercase; letter-spacing:0.5px; }
  .scores-table td { padding:6px 8px; border-bottom:1px solid rgba(26,26,53,0.5); }
  .scores-table tr:hover { background:rgba(255,255,255,0.02); }
  .scores-table tr.expandable { cursor:pointer; }
  .scores-table tr.expanded { background:rgba(61,232,160,0.03); }

  .signal-badge { font-size:9px; font-weight:600; padding:2px 7px; border-radius:3px; display:inline-block; }
  .signal-badge.long { background:rgba(61,232,160,0.12); color:var(--green); }
  .signal-badge.neutral { background:rgba(107,112,148,0.12); color:var(--dim); }
  .signal-badge.short { background:rgba(240,104,120,0.12); color:var(--red); }

  .contrib-row { background:var(--bg3); }
  .contrib-bar-wrap { display:flex; align-items:center; gap:6px; margin:2px 0; font-size:10px; }
  .contrib-bar { height:8px; border-radius:4px; min-width:2px; }
  .contrib-bar.pos { background:var(--green); }
  .contrib-bar.neg { background:var(--red); }

  .top10-card { padding:8px 10px; margin-bottom:4px; }
  .top10-card .sym { font-weight:600; font-size:12px; }
  .top10-card .score { font-size:11px; font-weight:600; }
  .top10-card .driver { font-size:9px; color:var(--dim); margin-top:2px; }

  .pagination { display:flex; gap:8px; align-items:center; justify-content:center; margin-top:14px; font-size:11px; color:var(--dim); }
  .pagination button { background:var(--bg3); border:1px solid var(--border); color:var(--text); border-radius:4px; padding:4px 12px; font:500 11px var(--mono); cursor:pointer; }
  .pagination button:disabled { opacity:0.3; cursor:default; }

  /* Loading */
  .loading { text-align:center; padding:80px 20px; color:var(--dim); }
  .loading .spinner { display:inline-block; width:24px; height:24px; border:2px solid var(--border); border-top-color:var(--green); border-radius:50%; animation:spin 0.8s linear infinite; margin-bottom:12px; }
  @keyframes spin { to { transform:rotate(360deg); } }

  /* Responsive */
  @media (max-width:900px) {
    .features-grid { grid-template-columns:1fr; }
    .period-grid { grid-template-columns:repeat(2,1fr); }
    .content { padding:16px; }
    .header { padding:20px 16px; }
    .tabs { padding:0 16px; }
  }
</style>
</head>
<body>

<div class="header">
  <h1><span class="g">Earnings</span> Signal <span class="b">Lab</span></h1>
  <div class="meta" id="meta">Loading...</div>
  <div class="source-bar" id="source-bar">
    <button class="source-btn active" data-source="earnings">Earnings Transcripts</button>
    <button class="source-btn" data-source="sec">SEC Filings</button>
    <button class="source-btn" data-source="combined">Combined</button>
  </div>
</div>

<div class="tabs" id="tabs">
  <button class="tab active" data-tab="features">Features</button>
  <button class="tab" data-tab="scores">Scores</button>
  <button class="tab" data-tab="models">Models</button>
  <button class="tab" data-tab="combos">Combinations</button>
  <button class="tab" data-tab="correlations">Correlations</button>
  <button class="tab" data-tab="summary">Summary</button>
</div>

<div class="content" id="content">
  <div class="loading"><div class="spinner"></div><div>Loading results...</div></div>
</div>

<script>
// ============================================================
// Feature metadata — per data source
// ============================================================
const FM_EARNINGS = {
  mgmt_hedging: { name:"Management Hedging", cat:"Management", color:"#e74c3c", bear:true, desc:"Hedging vs definitive language" },
  mgmt_deflection: { name:"Q&A Deflection", cat:"Management", color:"#c0392b", bear:true, desc:"Non-answers in Q&A" },
  mgmt_specificity: { name:"Guidance Specificity", cat:"Management", color:"#e67e22", bear:false, desc:"Specific numbers vs vague" },
  mgmt_confidence_shift: { name:"Confidence Shift", cat:"Management", color:"#d35400", bear:true, desc:"Drop from prepared to Q&A" },
  analyst_skepticism: { name:"Analyst Skepticism", cat:"Analyst", color:"#2980b9", bear:true, desc:"Challenging follow-ups" },
  analyst_surprise: { name:"Analyst Surprise", cat:"Analyst", color:"#3498db", bear:false, desc:"Unexpected info reactions" },
  analyst_focus_cluster: { name:"Question Clustering", cat:"Analyst", color:"#1abc9c", bear:false, desc:"Analysts converge on topic" },
  guidance_revision_dir: { name:"Guidance Direction", cat:"Guidance", color:"#9b59b6", bear:false, desc:"Raised vs lowered" },
  guidance_qualifiers: { name:"Qualifier Density", cat:"Guidance", color:"#8e44ad", bear:true, desc:"Conditional language" },
  new_risk_mention: { name:"New Risk Mentions", cat:"Risk", color:"#e74c3c", bear:true, desc:"First-time risk factors" },
  macro_blame: { name:"External Blame", cat:"Risk", color:"#c0392b", bear:true, desc:"Blaming macro vs ownership" },
  capex_language: { name:"CapEx Tone", cat:"Strategic", color:"#27ae60", bear:false, desc:"Expansion vs cautious" },
  hiring_language: { name:"Hiring Signals", cat:"Strategic", color:"#2ecc71", bear:false, desc:"Growth vs restructuring" },
  competitive_mentions: { name:"Competitive Position", cat:"Strategic", color:"#16a085", bear:true, desc:"Concerned vs dismissive" },
  customer_language: { name:"Demand Descriptors", cat:"Demand", color:"#f39c12", bear:false, desc:"Robust vs softening" },
  pricing_power: { name:"Pricing Power", cat:"Demand", color:"#f1c40f", bear:false, desc:"Raising vs discounting" },
};

const FM_SEC = {
  risk_score: { name:"Risk Score", cat:"AI Analysis", color:"#e74c3c", bear:true, desc:"Claude-assessed risk severity (0-10)" },
  sentiment_score: { name:"Sentiment", cat:"AI Analysis", color:"#27ae60", bear:false, desc:"MD&A sentiment (-1 to +1)" },
  concern_level: { name:"Concern Level", cat:"AI Analysis", color:"#c0392b", bear:true, desc:"Multi-factor concern synthesis (0-10)" },
  market_cap: { name:"Market Cap", cat:"Valuation", color:"#8e44ad", bear:false, desc:"Total market capitalization" },
  current_price: { name:"Current Price", cat:"Valuation", color:"#9b59b6", bear:false, desc:"Stock price at filing date" },
  pe_ratio: { name:"P/E Ratio", cat:"Valuation", color:"#8e44ad", bear:true, desc:"Price-to-earnings multiple" },
  forward_pe: { name:"Forward P/E", cat:"Valuation", color:"#9b59b6", bear:true, desc:"Forward price-to-earnings" },
  fifty_two_week_high: { name:"52W High", cat:"Valuation", color:"#2980b9", bear:false, desc:"52-week high price" },
  fifty_two_week_low: { name:"52W Low", cat:"Valuation", color:"#3498db", bear:false, desc:"52-week low price" },
  price_to_high: { name:"Price to High", cat:"Valuation", color:"#2980b9", bear:true, desc:"Price relative to 52-week high" },
  price_to_low: { name:"Price to Low", cat:"Valuation", color:"#3498db", bear:false, desc:"Price relative to 52-week low" },
  price_to_target: { name:"Price to Target", cat:"Valuation", color:"#1abc9c", bear:false, desc:"Price relative to analyst target" },
  price_to_ma30: { name:"Price/MA30", cat:"Technical", color:"#e67e22", bear:false, desc:"Price relative to 30-day MA" },
  price_to_ma50: { name:"Price/MA50", cat:"Technical", color:"#d35400", bear:false, desc:"Price relative to 50-day MA" },
  rsi14: { name:"RSI (14)", cat:"Technical", color:"#f39c12", bear:true, desc:"Relative Strength Index (overbought > 70)" },
  macd: { name:"MACD", cat:"Technical", color:"#e67e22", bear:false, desc:"Moving Average Convergence Divergence" },
  volatility30: { name:"Volatility 30D", cat:"Technical", color:"#e74c3c", bear:true, desc:"30-day price volatility" },
  return_30d: { name:"Prior 30D Return", cat:"Technical", color:"#2ecc71", bear:false, desc:"Trailing 30-day return (momentum)" },
  spx_return_7d: { name:"SPX 7D Return", cat:"Market Context", color:"#3498db", bear:false, desc:"S&P 500 7-day return" },
  spx_return_30d: { name:"SPX 30D Return", cat:"Market Context", color:"#2980b9", bear:false, desc:"S&P 500 30-day return" },
  vix_close: { name:"VIX Close", cat:"Market Context", color:"#e74c3c", bear:true, desc:"CBOE VIX volatility index" },
  analyst_upside_potential: { name:"Analyst Upside", cat:"Analyst Activity", color:"#27ae60", bear:false, desc:"Analyst-implied upside potential" },
  analyst_consensus_score: { name:"Analyst Consensus", cat:"Analyst Activity", color:"#2ecc71", bear:false, desc:"Analyst consensus rating score" },
  analyst_coverage: { name:"Analyst Coverage", cat:"Analyst Activity", color:"#16a085", bear:false, desc:"Number of covering analysts" },
  upgrades_last_30d: { name:"Upgrades (30D)", cat:"Analyst Activity", color:"#27ae60", bear:false, desc:"Analyst upgrades in last 30 days" },
  downgrades_last_30d: { name:"Downgrades (30D)", cat:"Analyst Activity", color:"#e74c3c", bear:true, desc:"Analyst downgrades in last 30 days" },
  net_upgrades: { name:"Net Upgrades", cat:"Analyst Activity", color:"#1abc9c", bear:false, desc:"Recent upgrades minus downgrades" },
  major_upgrades: { name:"Major Upgrades", cat:"Analyst Activity", color:"#2ecc71", bear:false, desc:"Upgrades from top-tier banks" },
  major_downgrades: { name:"Major Downgrades", cat:"Analyst Activity", color:"#c0392b", bear:true, desc:"Downgrades from top-tier banks" },
};

// Combined uses metadata from the API response
let FM_COMBINED = {};

// Active feature metadata (swapped on source change)
let FM = FM_EARNINGS;

function getFM() {
  // For combined, try API metadata first, then merge defaults
  if (activeSource === "combined" && DATA && DATA.metadata && DATA.metadata.feature_metadata) {
    const apiMeta = DATA.metadata.feature_metadata;
    const fm = {};
    for (const [key, meta] of Object.entries(apiMeta)) {
      fm[key] = {
        name: meta.name || key,
        cat: meta.cat || "Other",
        color: meta.color || "#6b7094",
        bear: meta.bear || false,
        desc: meta.desc || "",
      };
    }
    return fm;
  }
  if (activeSource === "sec") return FM_SEC;
  return FM_EARNINGS;
}

function getCategories() {
  return [...new Set(Object.values(FM).map(f=>f.cat))];
}

function getPeriods() {
  if (!DATA || !DATA.regression) return ["1D","5D","10D","21D"];
  return Object.keys(DATA.regression);
}

const SOURCE_LABELS = {
  earnings: "Earnings Transcripts",
  sec: "SEC Filings",
  combined: "Combined",
};

// ============================================================
// State
// ============================================================
let DATA = null;
let SCORES = null;
let MODEL = null;
let SOURCES = null;
let activeSource = "earnings";
let activeTab = "features";
let selectedFeat = null;
let catFilter = "All";
let scoreSignalFilter = "ALL";
let scoreConfFilter = "ALL";
let scoreOffset = 0;
let scoreLimit = 50;
let expandedScoreIdx = null;

// ============================================================
// Fetch data
// ============================================================
async function init() {
  // First fetch available sources
  try {
    const srcRes = await fetch("/api/sources");
    if (srcRes.ok) SOURCES = await srcRes.json();
  } catch(e) {}
  updateSourceButtons();
  await loadSource(activeSource);
}

async function loadSource(source) {
  activeSource = source;
  FM = getFM();

  // Reset state
  selectedFeat = null;
  catFilter = "All";
  scoreSignalFilter = "ALL";
  scoreConfFilter = "ALL";
  scoreOffset = 0;
  expandedScoreIdx = null;
  SCORES = null;
  MODEL = null;

  document.getElementById("content").innerHTML =
    `<div class="loading"><div class="spinner"></div><div>Loading ${SOURCE_LABELS[source] || source} data...</div></div>`;

  try {
    const [resultsRes, scoresRes, modelRes] = await Promise.all([
      fetch(`/api/results?source=${source}`),
      fetch(`/api/scores?source=${source}&limit=50`).catch(() => null),
      fetch(`/api/model?source=${source}`).catch(() => null),
    ]);
    if (!resultsRes.ok) throw new Error(`${resultsRes.status}: ${resultsRes.statusText}`);
    DATA = await resultsRes.json();
    if (scoresRes && scoresRes.ok) SCORES = await scoresRes.json();
    if (modelRes && modelRes.ok) MODEL = await modelRes.json();

    // Update FM from API metadata if available
    FM = getFM();

    renderMeta();
    renderTab();
  } catch(e) {
    document.getElementById("content").innerHTML =
      `<div class="loading" style="color:var(--red)">
        <div style="font-size:16px;margin-bottom:8px">No data available for ${SOURCE_LABELS[source] || source}</div>
        <div style="font-size:11px">${e.message}<br>Pipeline may not have run yet.</div>
       </div>`;
  }
}

function updateSourceButtons() {
  document.querySelectorAll(".source-btn").forEach(btn => {
    const src = btn.dataset.source;
    btn.classList.toggle("active", src === activeSource);
    if (SOURCES && SOURCES[src]) {
      btn.classList.toggle("unavailable", !SOURCES[src].available);
    }
  });
}

function renderMeta() {
  const m = DATA.metadata || {};
  const sourceLabel = SOURCE_LABELS[activeSource] || activeSource;
  let info = `<strong>${sourceLabel}</strong> · `;
  info += `<strong>${m.total_events||0}</strong> events · `;
  info += `<strong>${(m.companies||[]).length}</strong> companies`;
  if ((m.date_range||[]).length >= 2) {
    info += ` · ${m.date_range[0]} to ${m.date_range[1]}`;
  }
  info += ` · Updated: ${DATA.last_updated ? new Date(DATA.last_updated).toLocaleDateString() : "?"}`;
  document.getElementById("meta").innerHTML = info;
}

// ============================================================
// Source selector
// ============================================================
document.getElementById("source-bar").addEventListener("click", e => {
  const btn = e.target.closest(".source-btn");
  if (!btn || btn.classList.contains("unavailable")) return;
  const source = btn.dataset.source;
  if (source === activeSource) return;

  document.querySelectorAll(".source-btn").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");
  loadSource(source);
});

// ============================================================
// Tab routing
// ============================================================
document.getElementById("tabs").addEventListener("click", e => {
  if (!e.target.classList.contains("tab")) return;
  document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
  e.target.classList.add("active");
  activeTab = e.target.dataset.tab;
  renderTab();
});

function renderTab() {
  if (!DATA) return;
  const el = document.getElementById("content");
  switch(activeTab) {
    case "features": el.innerHTML = renderFeatures(); break;
    case "scores": el.innerHTML = renderScores(); break;
    case "models": el.innerHTML = renderModels(); break;
    case "combos": el.innerHTML = renderCombos(); break;
    case "correlations": el.innerHTML = renderCorrelations(); break;
    case "summary": el.innerHTML = renderSummary(); break;
  }
  attachListeners();
}

function icColor(ic) { const a=Math.abs(ic); return a>0.15?"var(--green)":a>0.08?"var(--amber)":"var(--dim)"; }
function retColor(r) { return r>0?"var(--green)":"var(--red)"; }

// ============================================================
// Features tab
// ============================================================
function renderFeatures() {
  const fids = Object.keys(FM);
  const cats = getCategories();
  const pds = getPeriods();
  const filtered = catFilter==="All" ? fids : fids.filter(f=>FM[f].cat===catFilter);
  const sorted = [...filtered].sort((a,b) => {
    const aD=DATA.features?.[a], bD=DATA.features?.[b];
    if(!aD&&!bD)return 0; if(!aD)return 1; if(!bD)return -1;
    return Math.max(...Object.values(bD).map(p=>Math.abs(p.ic||0))) - Math.max(...Object.values(aD).map(p=>Math.abs(p.ic||0)));
  });

  let filters = `<div class="filters">`;
  ["All",...cats].forEach(c => {
    filters += `<button class="filter-btn ${catFilter===c?"active":""}" data-cat="${c}">${c}</button>`;
  });
  filters += `</div>`;

  let list = `<div class="feat-list">`;
  sorted.forEach(fid => {
    const m=FM[fid], d=DATA.features?.[fid];
    if (!m) return;
    let bestIC=0, bestP="";
    if(d) Object.entries(d).forEach(([p,s])=>{ if(Math.abs(s.ic||0)>Math.abs(bestIC)){bestIC=s.ic;bestP=p;} });
    list += `<div class="card feat-card ${selectedFeat===fid?"selected":""}" data-fid="${fid}">
      <div style="display:flex;justify-content:space-between;align-items:flex-start">
        <div style="flex:1"><div class="feat-name" style="color:${m.color}">${m.name}</div>
          <div class="feat-desc">${m.desc}</div>
          ${m.bear?`<div class="feat-tag" style="color:var(--red);background:rgba(240,104,120,0.1)">bearish when high</div>`:""}
        </div>
        ${d?`<div><div class="feat-ic" style="color:${icColor(bestIC)}">${bestIC>0?"+":""}${bestIC.toFixed(3)}</div>
          <div style="font-size:9px;color:var(--dim);text-align:right">IC @ ${bestP}</div></div>`:""}
      </div>
      ${d?`<div class="feat-stats"><span>Acc: ${((d[bestP]?.accuracy||0)*100).toFixed(0)}%</span>
        <span>Win: ${((d[bestP]?.win_rate||0)*100).toFixed(0)}%</span>
        <span>p=${d[bestP]?.ic_pvalue?.toFixed(3)}</span>
        <span>n=${d[bestP]?.n_observations}</span></div>`:""}
    </div>`;
  });
  list += `</div>`;

  let detail = "";
  if (selectedFeat && DATA.features?.[selectedFeat]) {
    const m=FM[selectedFeat] || {name:selectedFeat, desc:"", color:"var(--text)"};
    const d=DATA.features[selectedFeat];
    detail = `<div class="card"><div style="font-size:15px;font-weight:700;color:${m.color};margin-bottom:2px">${m.name}</div>
      <div style="font-size:11px;color:var(--dim);margin-bottom:16px">${m.desc}</div>
      <div style="font-size:12px;font-weight:600;margin-bottom:8px">Signal by Holding Period</div>
      <div class="period-grid">${pds.map(p=>{
        const s=d[p]; if(!s) return `<div class="period-box" style="opacity:0.4"><div class="period-label">${p}</div><div>—</div></div>`;
        return `<div class="period-box"><div class="period-label">${p}</div>
          <div class="period-ic" style="color:${icColor(s.ic||0)}">${(s.ic||0)>0?"+":""}${(s.ic||0).toFixed(3)}</div>
          <div style="font-size:9px;color:var(--dim)">IC</div>
          <div class="period-stats">Acc: ${((s.accuracy||0)*100).toFixed(1)}%<br>Win: ${((s.win_rate||0)*100).toFixed(1)}%<br>
          Ret: ${(s.avg_return_pct||0)>0?"+":""}${(s.avg_return_pct||0).toFixed(2)}%<br>Sharpe: ${(s.sharpe||0).toFixed(2)}<br>
          p: ${(s.ic_pvalue||0).toFixed(4)}<br>n=${s.n_observations}</div></div>`;
      }).join("")}</div>`;

    // Samples
    const samples = DATA.sample_extractions?.[selectedFeat] || [];
    if(samples.length) {
      detail += `<div style="font-size:12px;font-weight:600;margin:16px 0 8px">Sample Signals</div>`;
      samples.forEach(s => {
        const sc = s.score>0.6?(m.bear?"var(--red)":"var(--green)"):s.score<0.4?(m.bear?"var(--green)":"var(--red)"):"var(--amber)";
        detail += `<div class="sample" style="border-left-color:${sc}">
          <div style="display:flex;justify-content:space-between;flex-wrap:wrap;gap:4px">
            <span style="font-weight:600">${s.symbol} <span style="color:var(--dim);font-weight:400">${s.quarter}</span></span>
            <div style="display:flex;gap:8px;align-items:center">
              <span style="font-size:10px;padding:1px 6px;border-radius:3px;background:rgba(255,255,255,0.04);color:var(--dim)">Score: ${s.score}</span>
              ${Object.entries(s).filter(([k])=>k.startsWith("return_")).map(([k,v])=>{
                if(v==null) return "";
                const label=k.replace("return_","");
                return `<span style="font-size:11px;font-weight:600;color:${retColor(v)}">${label}: ${v>0?"+":""}${Number(v).toFixed(1)}%</span>`;
              }).join("")}
            </div>
          </div></div>`;
      });
    }
    detail += `</div>`;
  } else {
    detail = `<div class="card" style="text-align:center;padding:60px 20px;color:var(--dim)">
      <div style="font-size:28px;margin-bottom:6px">&larr;</div>Select a feature to view details</div>`;
  }

  return filters + `<div class="features-grid">${list}<div>${detail}</div></div>`;
}

// ============================================================
// Scores tab
// ============================================================
async function fetchScores() {
  let url = `/api/scores?source=${activeSource}&limit=${scoreLimit}&offset=${scoreOffset}`;
  if (scoreSignalFilter !== "ALL") url += `&signal=${scoreSignalFilter}`;
  if (scoreConfFilter !== "ALL") url += `&confidence=${scoreConfFilter}`;
  const res = await fetch(url);
  if (res.ok) { SCORES = await res.json(); expandedScoreIdx = null; renderTab(); }
}

function renderScores() {
  if (!SCORES) return `<div class="loading" style="color:var(--dim)">No scores available. Run the scoring pipeline first.</div>`;

  const sum = SCORES.summary || {};
  const sigs = sum.signals || {};
  const total = sum.total || 1;
  const items = SCORES.items || [];

  const nActive = MODEL ? Object.values(MODEL.weights || {}).filter(w => w !== 0 && w !== -0).length : "?";
  const cvR2 = MODEL ? (MODEL.cv_r2 * 100).toFixed(2) : "?";
  const horizon = MODEL ? MODEL.horizon : "?";

  let html = `<div style="display:flex;justify-content:space-between;align-items:flex-end;flex-wrap:wrap;gap:8px;margin-bottom:14px">
    <div>
      <div style="font-size:14px;font-weight:600;margin-bottom:2px">Scored ${activeSource === "sec" ? "Filings" : activeSource === "combined" ? "Events" : "Transcripts"}</div>
      <div style="font-size:11px;color:var(--dim)">Lasso ${horizon} · CV R² ${cvR2}% · ${nActive} features · ${total} scored</div>
    </div></div>`;

  const lPct = ((sigs.LONG||0)/total*100).toFixed(1);
  const nPct = ((sigs.NEUTRAL||0)/total*100).toFixed(1);
  const sPct = ((sigs.SHORT||0)/total*100).toFixed(1);
  html += `<div class="signal-bar">
    <div class="signal-long" style="width:${lPct}%">${sigs.LONG||0} LONG</div>
    <div class="signal-neutral" style="width:${nPct}%">${sigs.NEUTRAL||0} NEUTRAL</div>
    <div class="signal-short" style="width:${sPct}%">${sigs.SHORT||0} SHORT</div>
  </div>`;

  // Filters
  html += `<div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:14px">
    <div class="filters" style="margin-bottom:0">`;
  ["ALL","LONG","SHORT","NEUTRAL"].forEach(s => {
    html += `<button class="filter-btn ${scoreSignalFilter===s?"active":""}" data-signal="${s}">${s}</button>`;
  });
  html += `</div><div class="filters" style="margin-bottom:0">`;
  ["ALL","high","medium","low"].forEach(c => {
    html += `<button class="filter-btn ${scoreConfFilter===c?"active":""}" data-conf="${c}">${c === "ALL" ? "All Conf." : c}</button>`;
  });
  html += `</div></div>`;

  html += `<div class="scores-layout">`;

  html += `<div class="card" style="padding:0;overflow-x:auto"><table class="scores-table">
    <thead><tr><th>#</th><th>Symbol</th><th>Qtr</th><th>Year</th><th>Score</th><th>Signal</th><th>Conf.</th><th>Top Driver</th></tr></thead><tbody>`;

  items.forEach((item, i) => {
    const rank = SCORES.offset + i + 1;
    const sigCls = item.signal.toLowerCase();
    const scoreColor = item.raw_score > 0 ? "var(--green)" : item.raw_score < 0 ? "var(--red)" : "var(--dim)";
    const contribs = item.feature_contributions || {};
    const topDriver = Object.entries(contribs).sort((a,b) => Math.abs(b[1]) - Math.abs(a[1]))[0];
    const topDriverName = topDriver ? (FM[topDriver[0]]?.name || topDriver[0]) : "\u2014";
    const isExpanded = expandedScoreIdx === i;

    html += `<tr class="expandable ${isExpanded ? "expanded" : ""}" data-score-idx="${i}">
      <td style="color:var(--dim)">${rank}</td>
      <td style="font-weight:600">${item.symbol}</td>
      <td>Q${item.quarter}</td>
      <td>${item.year}</td>
      <td style="font-weight:600;color:${scoreColor}">${item.raw_score > 0 ? "+" : ""}${item.raw_score.toFixed(2)}</td>
      <td><span class="signal-badge ${sigCls}">${item.signal}</span></td>
      <td style="font-size:10px;color:var(--dim)">${item.confidence}</td>
      <td style="font-size:10px">${topDriverName}</td>
    </tr>`;

    if (isExpanded) {
      const entries = Object.entries(contribs).sort((a,b) => Math.abs(b[1]) - Math.abs(a[1]));
      const maxAbs = Math.max(...entries.map(e => Math.abs(e[1])), 0.01);
      html += `<tr class="contrib-row"><td colspan="8" style="padding:10px 16px">
        <div style="font-size:10px;font-weight:600;color:var(--dim);margin-bottom:6px">FEATURE CONTRIBUTIONS</div>`;
      entries.forEach(([feat, val]) => {
        const barW = Math.abs(val) / maxAbs * 100;
        const cls = val >= 0 ? "pos" : "neg";
        const fName = FM[feat]?.name || feat;
        html += `<div class="contrib-bar-wrap">
          <span style="min-width:130px;color:${FM[feat]?.color || 'var(--text)'}">${fName}</span>
          <div style="flex:1;display:flex;align-items:center;${val < 0 ? "flex-direction:row-reverse" : ""}">
            <div class="contrib-bar ${cls}" style="width:${barW}%"></div>
          </div>
          <span style="min-width:50px;text-align:right;font-weight:600;color:${val >= 0 ? "var(--green)" : "var(--red)"}">${val > 0 ? "+" : ""}${val.toFixed(3)}</span>
        </div>`;
      });
      html += `</td></tr>`;
    }
  });

  html += `</tbody></table>`;

  // Pagination
  const totalFiltered = SCORES.total || 0;
  const hasPrev = scoreOffset > 0;
  const hasNext = scoreOffset + scoreLimit < totalFiltered;
  html += `<div class="pagination">
    <button id="scores-prev" ${hasPrev ? "" : "disabled"}>&larr; Prev</button>
    <span>${scoreOffset + 1}&ndash;${Math.min(scoreOffset + scoreLimit, totalFiltered)} of ${totalFiltered}</span>
    <button id="scores-next" ${hasNext ? "" : "disabled"}>Next &rarr;</button>
  </div></div>`;

  // Top 10 sidebar
  html += `<div>`;
  html += renderTop10("LONG", "var(--green)");
  html += renderTop10("SHORT", "var(--red)");
  html += `</div></div>`;

  return html;
}

function renderTop10(signal, color) {
  if (!SCORES) return "";
  const items = SCORES._top10?.[signal];
  if (!items) {
    fetchTop10(signal);
    return `<div class="card"><div style="font-size:12px;font-weight:600;color:${color};margin-bottom:8px">Top 10 ${signal}</div>
      <div style="font-size:10px;color:var(--dim)">Loading...</div></div>`;
  }
  let html = `<div class="card"><div style="font-size:12px;font-weight:600;color:${color};margin-bottom:8px">Top 10 ${signal}</div>`;
  items.forEach((item, i) => {
    const contribs = item.feature_contributions || {};
    const topDriver = Object.entries(contribs).sort((a,b) => Math.abs(b[1]) - Math.abs(a[1]))[0];
    const driverName = topDriver ? (FM[topDriver[0]]?.name || topDriver[0]) : "";
    html += `<div class="top10-card" style="border-left:2px solid ${color}; margin-left:0; padding-left:8px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <span class="sym">${i+1}. ${item.symbol}</span>
        <span class="score" style="color:${color}">${item.raw_score > 0 ? "+" : ""}${item.raw_score.toFixed(2)}</span>
      </div>
      <div class="driver">Q${item.quarter} ${item.year} · ${driverName}</div>
    </div>`;
  });
  html += `</div>`;
  return html;
}

async function fetchTop10(signal) {
  if (!SCORES) return;
  if (!SCORES._top10) SCORES._top10 = {};
  if (SCORES._top10[signal]) return;
  const res = await fetch(`/api/scores?source=${activeSource}&signal=${signal}&limit=10&offset=0`);
  if (res.ok) {
    const data = await res.json();
    SCORES._top10[signal] = data.items || [];
    if (activeTab === "scores") renderTab();
  }
}

// ============================================================
// Models tab
// ============================================================
function renderModels() {
  const reg = DATA.regression || {};
  if (!Object.keys(reg).length) return `<div class="loading" style="color:var(--dim)">No regression results available.</div>`;

  let html = `<div style="font-size:14px;font-weight:600;margin-bottom:4px">Regression Model Comparison</div>
    <div style="font-size:11px;color:var(--dim);margin-bottom:16px">Cross-validated R² — higher is better. Negative means worse than predicting the mean.</div>`;

  for (const [period, pdata] of Object.entries(reg)) {
    const comparison = pdata.model_comparison || [];
    const maxR2 = Math.max(...comparison.map(m=>m.cv_r2), 0.01);
    const weights = pdata.recommended_weights?.weights || {};
    const weightsSorted = Object.entries(weights).sort((a,b)=>Math.abs(b[1])-Math.abs(a[1]));

    html += `<div class="card"><div style="font-size:14px;font-weight:600;margin-bottom:4px">${period} Forward Returns</div>
      <div style="font-size:10px;color:var(--dim);margin-bottom:12px">n=${pdata.n_observations||"?"} · mean=${pdata.y_mean||"?"}% · std=${pdata.y_std||"?"}%</div>`;

    comparison.forEach((m,i) => {
      const barW = Math.max(0, m.cv_r2/maxR2*100);
      html += `<div class="model-row" ${i===0?'style="background:rgba(61,232,160,0.08)"':""}>
        <span style="font-size:11px;font-weight:${i===0?700:400};color:${i===0?"var(--green)":"var(--text)"}; min-width:140px">${m.model}${i===0?" ✦":""}</span>
        <div style="flex:1;margin:0 16px"><div class="model-bar" style="width:${barW}%;background:${i===0?"var(--green)":m.cv_r2>0?"var(--blue)":"var(--red)"}"></div></div>
        <span style="font-size:12px;font-weight:600;color:${m.cv_r2>0?"var(--green)":"var(--red)"}; min-width:70px;text-align:right">${m.cv_r2.toFixed(4)}</span>
      </div>`;
    });

    if (weightsSorted.length) {
      html += `<div style="margin-top:16px;font-size:12px;font-weight:600;margin-bottom:8px">Recommended Weights</div>
        <div style="font-size:10px;color:var(--dim);margin-bottom:8px">${pdata.recommended_weights?.method||""}</div>`;
      weightsSorted.forEach(([name,w]) => {
        html += `<div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px">
          <span style="color:${FM[name]?.color||"var(--text)"}">${FM[name]?.name||name}</span>
          <span style="font-weight:600;color:${w>0?"var(--green)":"var(--red)"}">${w>0?"+":""}${w.toFixed(4)}</span></div>`;
      });
    }
    html += `</div>`;
  }
  return html;
}

// ============================================================
// Combinations tab
// ============================================================
function renderCombos() {
  const combos = DATA.combinations || [];
  if (!combos.length) return `<div class="loading" style="color:var(--dim)">No combination results.</div>`;

  let html = `<div style="font-size:14px;font-weight:600;margin-bottom:4px">Multi-Feature Combinations</div>
    <div style="font-size:11px;color:var(--dim);margin-bottom:14px">Combining uncorrelated features for stronger composite signals</div>`;

  [...combos].sort((a,b)=>Math.abs(b.sharpe)-Math.abs(a.sharpe)).forEach(c => {
    const color = Math.abs(c.sharpe)>1?"var(--green)":Math.abs(c.sharpe)>0.5?"var(--amber)":"var(--blue)";
    html += `<div class="card combo" style="border-left-color:${color}">
      <div style="display:flex;justify-content:space-between;align-items:flex-start">
        <div><div style="font-size:13px;font-weight:600">${c.name}</div>
          <div style="display:flex;gap:4px;margin-top:6px;flex-wrap:wrap">
            ${(c.features||[]).map(f=>`<span style="font-size:9px;padding:1px 6px;border-radius:3px;background:${FM[f]?.color||"#666"}22;color:${FM[f]?.color||"#999"}">${FM[f]?.name||f}</span>`).join("")}
          </div></div>
        <div style="text-align:right;flex-shrink:0;margin-left:12px">
          <div style="font-size:20px;font-weight:700;color:${color}">${(c.sharpe||0).toFixed(2)}</div>
          <div style="font-size:9px;color:var(--dim)">Sharpe @ ${c.period}</div></div></div>
      <div style="display:flex;gap:12px;margin-top:8px;font-size:10px;color:var(--dim)">
        <span>Avg: ${(c.avg_return||0)>0?"+":""}${(c.avg_return||0).toFixed(2)}%</span>
        <span>Win: ${((c.win_rate||0)*100).toFixed(0)}%</span>
        <span>${c.n_triggered}/${c.n_total} triggered</span></div></div>`;
  });
  return html;
}

// ============================================================
// Correlations tab
// ============================================================
function renderCorrelations() {
  const matrix = DATA.correlation_matrix || {};
  const allKeys = Object.keys(matrix);
  const fs = allKeys.filter(f=>FM[f]).slice(0,16);
  if (!fs.length) {
    // If FM doesn't match (e.g. combined mode), show all keys
    const fallbackFs = allKeys.slice(0, 16);
    if (!fallbackFs.length) return `<div class="loading" style="color:var(--dim)">No correlation data.</div>`;
    return renderCorrMatrix(fallbackFs, matrix);
  }
  return renderCorrMatrix(fs, matrix);
}

function renderCorrMatrix(fs, matrix) {
  let html = `<div style="font-size:14px;font-weight:600;margin-bottom:4px">Feature Correlation Matrix</div>
    <div style="font-size:11px;color:var(--dim);margin-bottom:14px">High correlation = redundant signal. Combine uncorrelated features.</div>
    <div style="overflow-x:auto"><table class="corr-table"><thead><tr><th></th>`;
  fs.forEach(f => {
    const label = FM[f]?.name?.split(" ")[0] || f.split("_")[0];
    html += `<th style="color:${FM[f]?.color||"var(--text)"}">${label}</th>`;
  });
  html += `</tr></thead><tbody>`;
  fs.forEach(f1 => {
    const label = FM[f1]?.name?.split(" ")[0] || f1.split("_")[0];
    html += `<tr><td class="label" style="color:${FM[f1]?.color||"var(--text)"}">${label}</td>`;
    fs.forEach(f2 => {
      const v=matrix[f1]?.[f2]??0, a=Math.abs(v);
      const bg = f1===f2 ? "var(--bg3)" : a>0.5?`rgba(240,104,120,${a*0.4})` : a>0.3?`rgba(240,200,72,${a*0.35})` : a>0.1?`rgba(61,232,160,${a*0.25})`:"rgba(255,255,255,0.02)";
      html += `<td><div class="corr-cell" style="background:${bg};font-weight:${a>0.3?600:400};color:${f1===f2?"var(--dim)":"var(--text)"}">${f1===f2?"\u2014":v.toFixed(2)}</div></td>`;
    });
    html += `</tr>`;
  });
  html += `</tbody></table></div>`;
  return html;
}

// ============================================================
// Summary tab
// ============================================================
function renderSummary() {
  const md = DATA.summary || "";
  if (!md) return `<div class="loading" style="color:var(--dim)">No summary available. Run the pipeline with Claude API to generate one.</div>`;

  let html = md
    .replace(/^## (.+)$/gm, '<h2>$1</h2>')
    .replace(/^### (.+)$/gm, '<h3 style="font-size:15px;color:var(--blue);margin:20px 0 8px">$1</h3>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/^- (.+)$/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
    .replace(/\n\n/g, '<br><br>')
    .replace(/\n(?!<)/g, '<br>');

  return `<div class="summary-content">${html}</div>`;
}

// ============================================================
// Event listeners
// ============================================================
function attachListeners() {
  // Feature cards
  document.querySelectorAll(".feat-card").forEach(el => {
    el.addEventListener("click", () => {
      selectedFeat = el.dataset.fid;
      renderTab();
    });
  });
  // Category filters (features tab)
  document.querySelectorAll(".filter-btn[data-cat]").forEach(el => {
    el.addEventListener("click", () => {
      catFilter = el.dataset.cat;
      renderTab();
    });
  });
  // Signal filters (scores tab)
  document.querySelectorAll(".filter-btn[data-signal]").forEach(el => {
    el.addEventListener("click", () => {
      scoreSignalFilter = el.dataset.signal;
      scoreOffset = 0;
      if (SCORES) SCORES._top10 = null;
      fetchScores();
    });
  });
  // Confidence filters (scores tab)
  document.querySelectorAll(".filter-btn[data-conf]").forEach(el => {
    el.addEventListener("click", () => {
      scoreConfFilter = el.dataset.conf;
      scoreOffset = 0;
      fetchScores();
    });
  });
  // Score row expansion
  document.querySelectorAll("tr.expandable").forEach(el => {
    el.addEventListener("click", () => {
      const idx = parseInt(el.dataset.scoreIdx);
      expandedScoreIdx = expandedScoreIdx === idx ? null : idx;
      renderTab();
    });
  });
  // Pagination
  const prevBtn = document.getElementById("scores-prev");
  const nextBtn = document.getElementById("scores-next");
  if (prevBtn) prevBtn.addEventListener("click", () => { scoreOffset = Math.max(0, scoreOffset - scoreLimit); fetchScores(); });
  if (nextBtn) nextBtn.addEventListener("click", () => { scoreOffset += scoreLimit; fetchScores(); });
}

// ============================================================
// Boot
// ============================================================
init();
</script>
</body>
</html>
